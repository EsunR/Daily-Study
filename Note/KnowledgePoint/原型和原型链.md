# 题目：
- 如何准确判断一个变量是数组类型
- 写一个原型链继承的例子
- 描述new一个对象的过程
- zepto（或其他框架）源码中如何使用原型链

# 知识点：

## 1. 构造函数
- 构造函数要用大写字母开头
- var a=其实是var a=new Object）的语法糖
- var a=[]其实是var a=new Array）的语法糖
- function Foo）{..}其实是var Foo=new Function（.）
- 使用instanceof 可以判断一个函数是否是一个变量的构造函数

![](https://ws1.sinaimg.cn/large/a71efaafly1g2rc6awjmxj20mf0dzwhx.jpg)

## 2. 原型规则和示例

- 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null"意外）
- 所有的**引用类型**（数组、对象、函数），都有一个_proto_（隐式原型）属性，属性值是一个普通的对象
- 所有的**函数**，都有一个prototype（显式原型）属性，属性值也是一个普通的对象
- 所有的引用类型（数组、对象、函数），_proto_属性值指向它的构造函数的"prototype"属性值

![](https://ws1.sinaimg.cn/large/a71efaafly1g2rchgklygj20mg0e4dk5.jpg) 

- 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即它的构造函数的prototype）中寻找。

我们再一个构造函数的显式原型上去定义方法可以有效的减少内存占用，因为如果我们定义在构造函数内部，则每实例化一个对象，就会开辟一个堆内存去存放挂载到其实例上，然而对于方法的调用这是没有必要的

![](https://ws1.sinaimg.cn/large/a71efaafly1g2rcm3gp5cj20me0e377t.jpg)

利用 `for in` 循环可以来获取对象身上自己定义的属性而不获取来自原型的属性

![](https://ws1.sinaimg.cn/large/a71efaafly1g2rcrpqiwvj20mk0e0tbu.jpg)

## 3. 原型链

当一个方法在原型上没有时，就会查找原型链

![](https://ws1.sinaimg.cn/large/a71efaafly1g2rcwekrs7j20mj0du0vy.jpg)

![](https://ws1.sinaimg.cn/large/a71efaafly1g2rd0r86dzj20mm0drmyo.jpg)