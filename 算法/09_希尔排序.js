/*
  先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

  两个元素之间相隔的元素为增量值-1
*/

function ShellSort(arr) {
  var len = arr.length;
  gap = Math.floor(len / 2); // 初始增量
  while (gap !== 0) { // 当增量不等于0的时候
    // 这种排序的模式是：以一次gap的变更为开始，将原始数组分割成若干个小数组
    for (var i = gap; i < len; i++) {
      var temp = arr[i]; // 用temp来保存要进行插入排序的数（每一个temp的排序对象是这个temp所在的小数组）
      var j; // j的初始值为temp所在的小数组的前一位元素
      for (j = i - gap; j >= 0 && temp < arr[j]; j -= gap) {
        // temp以插入排序的思想，排入已排序的数组中
        arr[j + gap] = arr[j];
      }
      arr[j + gap] = temp;
      // 注意每次i++之后，就将单前排序的小数组先跳过了，开始进行下一个小数组的排序。
      // 比如说当前是在把第一个小数组的3号元素插入到已排序数组的合适位置，那么i++之后就是该把第二个小数组的3号元素插入到已排序的数组的合适位置 ... ... 依次向后推，直至i增加到了第一个小数组的4号元素的位置，就开始再拍第一个小数组。
    }
    //
    gap = Math.floor(gap / 2);
  }
  return arr;
}

console.log(ShellSort([5,4,3,2,1,6,4]));