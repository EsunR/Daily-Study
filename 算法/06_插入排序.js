/**
 * 插入排序（insertion sort）比前面两种排序方法都更有效率。它将数组分成“已排序”和“未排序”两部分，一开始的时候，“已排序”的部分只有一个元素，然后将它后面一个元素从“未排序”部分插入“已排序”部分，从而“已排序”部分增加一个元素，“未排序”部分减少一个元素。以此类推，完成全部排序。
 */

let myArr = [4, 5, 1, 6, 3, 2, 1, 1, 1];

function insertionSort(myArr) {
  let i, j;
  for (i = 0; i < myArr.length; i++) {
    // 把将要排序的数字存起来
    let value = myArr[i];
    // 将将要排序的数字与前一位进行比较;
    // 如果前一位的数字比要排序的数字小，就将当前位的数字赋值为较小的那个数字赋值为前一个数字，并对比前前一位，直至比出一位比要排序的数字小的数，就将要排序的数字插在其前一位。
    // [1,3,4, | 2,5]
    // value = 2
    // 4 > 2 √
    // [1,3,4,4, | 5]
    // 3 > 2 √
    // [1,3,3,4, | 5]
    // 1 > 3 × 找到了比要排序数字大的数“1”，终止遍历，并将其插在“1”前一位
    // [1,2,3,4, | 5]
    for (j = i - 1; j > -1; j--) {
      // myArr[j]指的是要对比的前一位数字
      // 如果要对比的前一位数字比要排序的数字（value）大，就将其值赋值给下一位（就相当于挪出当前的一个坑位等着被插入）
      if (myArr[j] > value) {
        myArr[j + 1] = myArr[j];
      } else {
        // 前一位数字比要排序的数字小（value）了，惹不起，那么就不比较了，记录j之后走人
        break
      }
    }
    // 将要排序的数字插在惹不起的数字的前一位，此时这个惹不起的数字的前一位的值，已经赋值给前前一位了，当前坑位只不过是一个拷贝。
    myArr[j + 1] = value;
  }
  return myArr;
}


console.log(insertionSort(myArr));

